NumpyOfficialTutorial
---------------------

ndarray - 
==========
NumPy’s array class is called ndarray. It is also known by the alias array. Note that numpy.array is not the same as the Standard Python Library class array.array, which only handles one-dimensional arrays and offers less functionality. The more important attributes of an ndarray object are:

a = np.arange(20).reshape(5,4)
print(a.ndim) # 2
print(a.shape) # (5,4)
print(a.size) # 20
print(a.dtype) # int64
print(a.itemsize) # 8, size of each item in a array in byte
print(a.data) # 0x126b50520 - Memory location
print(type(a)) # <class 'numpy.ndarray'>

Array Creation
==============
There are several ways to create arrays.
For example, you can create an array from a regular Python list or tuple using the array function. The type of the resulting array is deduced from the type of the elements in the sequences.
>>> import numpy as np
>>> a = np.array([2, 3, 4])

A frequent error consists in calling array with multiple arguments, rather than providing a single sequence as an argument.
>>> a = np.array(1, 2, 3, 4)    # WRONG
TypeError: array() takes from 1 to 2 positional arguments but 4 were given

array transforms sequences of sequences into two-dimensional arrays, sequences of sequences of sequences into three-dimensional arrays, and so on.
a = np.array([[1,1,[2,3]], [2,[2,4],3], [[3,1],3,4]], dtype='object')
a.shape # (3, 3)
(If we want to create an array of more than 2D then dtype needs to be specified.)

Often, the elements of an array are originally unknown, but its size is known. Hence, NumPy offers several functions to create arrays with initial placeholder content. These minimize the necessity of growing arrays, an expensive operation.

The function zeros creates an array full of zeros, the function ones creates an array full of ones, and the function empty creates an array whose initial content is random and depends on the state of the memory. By default, the dtype of the created array is float64, but it can be specified via the key word argument dtype.

np.zeros([2,2])
array([[0., 0.],
       [0., 0.]])

np.ones((3,3), dtype=np.int16)
array([[1, 1, 1],
       [1, 1, 1],
       [1, 1, 1]], dtype=int16)

np.empty([2,2])
array([[0.0e+000, 4.9e-324],
       [9.9e-324, 1.5e-323]])

arange - 
To create sequences of numbers, NumPy provides the arange function which is analogous to the Python built-in range, but returns an array.
>>> np.arange(0, 2, 0.3)  # it accepts float arguments
array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])

linspace:
When arange is used with floating point arguments, it is generally not possible to predict the number of elements obtained, due to the finite floating point precision. For this reason, it is usually better to use the function linspace that receives as an argument the number of elements that we want, instead of the step:
np.linspace(0,2,9)

Printing Arrays
One-dimensional arrays are then printed as rows, bidimensionals as matrices and tridimensionals as lists of matrices.
3-D array as list of 2D array
If we want to a 3D array with two 2D array then
np.arange(24).reshape(2,3,4)

If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners:
np.arange(100000) # array([    0,     1,     2, ..., 99997, 99998, 99999])
np.arange(10000).reshape(100,100)

To disable this behaviour and force NumPy to print the entire array, you can change the printing options using set_printoptions.
>>> np.set_printoptions(threshold=sys.maxsize)

Unlike in many matrix languages, the product operator * operates elementwise in NumPy arrays. The matrix product can be performed using the @ operator (in python >=3.5) or the dot function or method:
a = np.array([[1,1],[0,1]])
b = np.array([[2,0],[3,4]])
a*b
array([[2, 0],
       [0, 4]])
a @ b
array([[5, 4],
       [3, 4]])
a.dot(b)
array([[5, 4],
       [3, 4]])

Some operations, such as += and *=, act in place to modify an existing array rather than create a new one.
rg = np.random.default_rng(1) ## create instance of default random number generator
a = np.ones([2,3], dtype=int)
b = rg.random([2,3])
a *= 3
array([[3, 3, 3],
       [3, 3, 3]])
b += a
array([[3.51182162, 3.9504637 , 3.14415961],
       [3.94864945, 3.31183145, 3.42332645]])

a += b # b is not automatically converted to integer type
UFuncTypeError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'

When operating with arrays of different types, the type of the resulting array corresponds to the more general or precise one (a behavior known as upcasting).

a = np.ones(3, dtype=np.int32)
b = np.linspace(0, np.pi, 3)
b.dtype.name # 'float64'
a.dtype.name # 'int32'
c = a + b
c.dtype.name # 'float64'
d = np.exp(c*1j)
d.dtype.name # 'complex128'

Many unary operations, such as computing the sum of all the elements in the array, are implemented as methods of the ndarray class.

a = rg.random((2,3))
a.sum() # 2.412
a.max() # 0.980
a.min() # 0.160
a.mean() # 0.593
a.var() # 0.0829
a.std() # 0.329

By default, these operations apply to the array as though it were a list of numbers, regardless of its shape. However, by specifying the axis parameter you can apply an operation along the specified axis of an array:
b = np.arange(6).reshape(2,3)
print(b)
b.sum(axis=1) # sum of each row
b.sum(axis=0) # sum of each column
b.cumsum(axis=0) # cumulative sum of each 
[[0 1 2]
 [3 4 5]]
array([[0, 1, 2],
       [3, 5, 7]])

NumPy provides familiar mathematical functions such as sin, cos, and exp. In NumPy, these are called “universal functions” (ufunc). Within NumPy, these functions operate elementwise on an array, producing an array as output.

b = np.arange(3) # array([0, 1, 2])
print(b)
np.exp(b) # array([1.        , 2.71828183, 7.3890561 ])
np.sqrt(b) # array([0.        , 1.        , 1.41421356])
c = np.array([2., -1., 4.])
print('*'*10)
print(c)
print('*'*10)
np.add(b,c) # array([2., 0., 6.])
np.all(b) # False
np.any(b) # True
d = np.array([[9 ,11, 2], [1, 6, 8]])
print(d)

# Apply a function to 1-D slices along the given axis.
np.apply_along_axis(lambda x: (x[0] + x[-1])*.5 , 1, d )  # array([2., 8.])
# np.apply_over_axes  ## Apply the function over multiple axis

np.argmax(d) # 1  -- return the max index
np.argmin(d) # 3  -- return the max index
np.max(d) # 11    -- returns max value

np.argsort(d) ## get the index of the elements as per sorted list

np.average(np.arange(1, 5), weights=np.arange(4)) # 3.33 ## Returns weighted average
px = np.array([19,19.10,21,20.05])
vol = np.array([100,110, 10000, 110000])
np.average(px, weights=vol)

# occurence of each element in an array 
np.bincount([1,2,1,2,1,4]) #  array([0, 3, 2, 0, 1])

np.ceil(4.05) # 5

numpy.clip(a, a_min, a_max, out=None, **kwargs)[source]
Clip (limit) the values in an array.
Given an interval, values outside the interval are clipped to the interval edges. For example, if an interval of [0, 1] is specified, values smaller than 0 become 0, and values larger than 1 become 1.

np.clip(np.arange(10), a_min=1, a_max=8) # array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])

np.corrcoef - Return Pearson product-moment correlation coefficients.
rg = np.random.default_rng(seed=42)
xarr = rg.random((3, 3))
np.corrcoef(xarr)

np.cov - Estimate a covariance matrix, given data and weights.

np.cross - Return the cross product of two (arrays of) vectors.
np.cross(np.arange(1,4), np.arange(2,5))

np.cumprd - Return the cumulative product of elements along a given axis.
np.cumprod(np.arange(1,6))[-1] # to get the factorial

np.cumsum - Return the cumulative sum of the elements along a given axis.
np.cumsum(np.arange(1,6)) # array([ 1,  3,  6, 10, 15])

np.diff - Calculate the n-th discrete difference along the given axis.
The first difference is given by out[i] = a[i+1] - a[i] along the given axis, higher differences are calculated by using diff recursively.
np.diff(np.arange(5)) # array([1, 1, 1, 1])

numpy.dot(a, b, out=None) - Dot product of two arrays. Specifically,
x, y = np.ogrid[:3, :4]
x @ y
x.dot(y)

np.floor - Return the floor of the input, element-wise.

np.inner - product and sum of all elements of two arrays
np.inner(np.arange(1,3), np.arange(1,3)) # 5

np.invert - Compute bit-wise inversion, or bit-wise NOT, element-wise.
np.bitwise_not is np.invert # True
np.invert([2]) # array([-3])
np.invert(-1*np.arange(5)) # array([-1, -2, -3, -4, -5])
np.invert([True, False]) # array([False,  True])

np.lexsort - Perform an indirect stable sort using a sequence of keys.
names = ('Ramesh', 'Suresh', 'Chandu')
surname = ('Ray', 'Cur', 'Shu')
[surname[i] + "," + names[i] for i in np.lexsort((names, surname))]

np.maximum - Maximum value across each element in two arrays
np.maximum([1,5,3], [2,3,4]) # array([2, 5, 4])

np.mean(np.arange(1,6)) # 3.0
np.median(np.arange(6,1,-1)) # 4.0

np.minimum([1,5,3], [2,3,4]) # array([1, 3, 3])

np.nonzero - Return the indices of the elements that are non-zero.
np.nonzero([0,1,0,1,0,2,0,21.]) # (array([1, 3, 5, 7]),)

np.outer - Compute the outer product of two vectors.
np.outer(np.arange(1,3), np.arange(3,5))
array([[3, 4],
       [6, 8]])

np.prod - Return the product of array elements over a given axis.
np.prod(np.arange(1,6)) # 120, factorial

np.re - regular expression

np.round - round off the number
np.round([1.3, 1.5]) # array([1., 2.])

np.sort - Return a sorted copy of an array.
np.sort(np.arange(10,1,-2)) # array([ 2,  4,  6,  8, 10])

np.std(np.arange(1,5)) # 1.118
np.var(np.arange(1,5)) # 1.25

np.sum(np.arange(1,11)) # 55

np.trace - add diagonals of an array
np.trace(np.eye(3)) # 3.0
np.trace(np.arange(1,10).reshape(3,3))

np.transpose(np.arange(1,7).reshape(2,3))

np.vdot - Return the dot product of two vectors.
np.vdot(np.arange(1,5).reshape(2,2), np.arange(1,5).reshape(2,2)) # 30

Broadcasting in Numpy:
----------------------
Advanced Concept in Numpy to perform operations of numpy.
The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is “broadcast” across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are, however, cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation
Rules:
1. arrays of same length can be added, subtracted, multiplied etc
       print(np.arange(1,5) + np.arange(1,5))
2. arrays can be multiplied by a scaler.
       print(np.arange(1,5) * 2)
3. 2D array and 1D array can be multiplied if number of elements in 1D array equals number of columns in 2D array.
       print(np.arange(9).reshape(3,3) + np.arange(1,4))
4. transposed arrays of same length can be multiplied.
       a = np.array([0, 10, 20, 30])
       b = np.array([1., 2., 3.])
       a[:, np.newaxis] + b


np.vectorize:
GENERALIZED FUNCTION CLASS.
Define a vectorized function which takes a nested sequence of objects or numpy arrays as inputs and returns a single numpy array or a tuple of numpy arrays. The vectorized function evaluates pyfunc over successive tuples of the input arrays like the python map function, except it uses the broadcasting rules of numpy.

The vectorize function is provided primarily for convenience, not for performance. The implementation is essentially a for loop.

def myfunc(a,b):
    return a-b if a>b else b-a

vfunc = np.vectorize(myfunc)
vfunc(np.array([100, 90, 80, 70]),10)

np.where:
numpy.where(condition[, x, y])
Return elements chosen from x or y depending on condition.

When only condition is provided, this function is a shorthand for np.asarray(condition).nonzero(). Using nonzero directly should be preferred, as it behaves correctly for subclasses. The rest of this documentation covers only the case where all three arguments are provided.
If all the arrays are 1-D, where is equivalent to:

[xv if c else yv for c, xv, yv in zip(condition, x, y)]

a = np.arange(10)
np.where(a>3, a, a*10)

Indexing, Slicing and Iterating
--------------------------------
One-dimensional arrays can be indexed, sliced and iterated over, much like lists and other Python sequences.

a = np.arange(10)**3
a # array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])

a[2]
a[:6:2]
for i in a:
    print(i**(1/3))

np.fromfunction: Construct an array by executing a function over each coordinate(index).
np.fromfunction(lambda i,j: i+j, (3,3), dtype=int)
array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])
It is adding the index 0,0 , 0,1 etc

np.fromfunction(lambda i,j: i==j, (3,3), dtype=int)
array([[ True, False, False],
       [False,  True, False],
       [False, False,  True]])

Multidimensional arrays can have one index per axis. These indices are given in a tuple separated by commas:

b = np.fromfunction(lambda i,j:10*i+j, (5,4), dtype=int)
print(b)
b[2,3]
b[0:4, 1] # # each row in the second column of b

When fewer indices are provided than the number of axes, the missing indices are considered complete slices:
b[-1] # array([40, 41, 42, 43])

The expression within brackets in b[i] is treated as an i followed by as many instances of : as needed to represent the remaining axes. NumPy also allows you to write this using dots as b[i, ...].

The dots (...) represent as many colons as needed to produce a complete indexing tuple. For example, if x is an array with 5 axes, then

x[1, 2, ...] is equivalent to x[1, 2, :, :, :],
x[..., 3] to x[:, :, :, :, 3] and
x[4, ..., 5, :] to x[4, :, :, 5, :].

b[1,...] # array([10, 11, 12, 13])

Iterating over multidimensional arrays is done with respect to the first axis:
for row in b:
    print(row*10)

However, if one wants to perform an operation on each element in the array, one can use the flat attribute which is an iterator over all the elements of the array:
for element in b.flat:
    print(element)

SHAPE MANIPULATION
------------------
Changing the shape of an array
An array has a shape given by the number of elements along each axis:

rg = np.random.default_rng(seed=42)
a = np.floor(10*rg.random((3,4)))
a.shape

The shape of an array can be changed with various commands. Note that the following three commands all return a modified array, but do not change the original array:

a.ravel() # array([7., 4., 8., 6., 0., 9., 7., 7., 1., 4., 3., 9.])
# returns the array, flattened  - similar to raze in kdb

a.reshape(2,6) # # returns the array with a modified shape

a.T # # returns the array, transposed

The order of the elements in the array resulting from ravel is normally “C-style”, that is, the rightmost index “changes the fastest”, so the element after a[0, 0] is a[0, 1]. If the array is reshaped to some other shape, again the array is treated as “C-style”. NumPy normally creates arrays stored in this order, so ravel will usually not need to copy its argument, but if the array was made by taking slices of another array or created with unusual options, it may need to be copied. The functions ravel and reshape can also be instructed, using an optional argument, to use FORTRAN-style arrays, in which the leftmost index changes the fastest.

The reshape function returns its argument with a modified shape, whereas the ndarray.resize method modifies the array itself:

a.shape # (3, 4)
a.resize(4,3)
a.shape # (4, 3)

If a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated:
a.reshape(6,-1) 
In this case you need no do the math that I want to convert a 4*3 matrix into 6*2, you just give 6,-1, the reshape method will do the math for you and provide an array of 6 rows and 2 columns

STACKING TOGETHER DIFFERENT ARRAYS -- APPENDING ARRAYS
----------------------------------- 
Several arrays can be stacked together along different axes:
Arrays can be appended horizontally and vertically.
a = np.arange(4).reshape(2,-1)
b = np.arange(5,9).reshape(2,-1)
np.stack((a,b), axis=0) ## append the array without modifying the dimensions
array([[[0, 1],
        [2, 3]],

       [[5, 6],
        [7, 8]]])

np.vstack((a,b))
array([[0, 1],
       [2, 3],
       [5, 6],
       [7, 8]])
np.hstack((a,b))
array([[0, 1, 5, 6],
       [2, 3, 7, 8]])

Eg with single dimentional array
a = np.arange(5)
b = np.arange(5)
np.stack((a,b), axis=0)
array([[0, 1, 2, 3, 4],
       [0, 1, 2, 3, 4]])
np.stack((a,b), axis=1)
array([[0, 0],
       [1, 1],
       [2, 2],
       [3, 3],
       [4, 4]])

np.dstack((a,b))
array([[0, 0],
       [1, 1],
       [2, 2],
       [3, 3],
       [4, 4]])

np.vstack((a,b))
array([[0, 1, 2, 3, 4],
       [0, 1, 2, 3, 4]])

np.hstack((a,b))
array([0, 1, 2, 3, 4, 0, 1, 2, 3, 4])

The function column_stack stacks 1D arrays as columns into a 2D array. It is equivalent to hstack only for 2D arrays:
a = np.arange(5)
b = np.arange(5,10)
np.column_stack((a,b))
array([[0, 5],
       [1, 6],
       [2, 7],
       [3, 8],
       [4, 9]])
a = np.arange(5)
b = np.arange(5,10)
np.row_stack((a,b))
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])

On the other hand, the function row_stack is equivalent to vstack for any input arrays. In fact, row_stack is an alias for vstack:
np.row_stack is np.vstack # True

Note
In complex cases, r_ and c_ are useful for creating arrays by stacking numbers along one axis. They allow the use of range literals :
np.r_[1:4,11,22] # array([ 1,  2,  3, 11, 22])
np.c_[1:4,1:4]
       array([[1, 1],
       [2, 2],
       [3, 3]])
When used with arrays as arguments, r_ and c_ are similar to vstack and hstack in their default behavior, but allow for an optional argument giving the number of the axis along which to concatenate.

SPLITTING ONE ARRAY INTO SEVERAL SMALLER ONES - SEGREGATING ARRAYS
-------------------------------------------------------------------
np.split, np.dsplit, np.hsplit and np.vsplit
Using hsplit, you can split an array along its horizontal axis, either by specifying the number of equally shaped arrays to return, or by specifying the columns after which the division should occur:
vsplit splits along the vertical axis, and array_split allows one to specify along which axis to split.

a = np.arange(16)
np.split(a,2)
[array([0, 1, 2, 3, 4, 5, 6, 7]), array([ 8,  9, 10, 11, 12, 13, 14, 15])]

a = np.arange(16).reshape(2,2,4)
np.dsplit(a,2)
[array([[[ 0,  1],
         [ 4,  5]],
 
        [[ 8,  9],
         [12, 13]]]),
 array([[[ 2,  3],
         [ 6,  7]],
 
        [[10, 11],
         [14, 15]]])]

a = np.arange(16).reshape(4,-1)

np.hsplit(a, 2)
np.vsplit(a,2)

np.array_split: splits an array into n subarrays.
a = np.arange(6)
np.array_split(a, 4) # [array([0, 1]), array([2, 3]), array([4]), array([5])]

a = np.arange(2)
np.array_split(a, 3) # [array([0]), array([1]), array([], dtype=int64)]

It is different from np.split in the sense that np.split can split the array into equal sized arrays but np.array_split can split the array into any number of arrays
a = np.arange(6)
np.split(a, 4) ## It will fail with Value error but np.array_split won't.



COPIES AND VIEWS
----------------
Copies and Views
When operating and manipulating arrays, their data is sometimes copied into a new array and sometimes not. This is often a source of confusion for beginners. There are three cases:

NO COPY AT ALL
---------------
Simple assignments make no copy of objects or their data.
a = np.arange(5)
b = a
print(id(a)) # 4902824816
print(id(b)) # 4902824816
print(a is b) # True
print(a == b) # [ True  True  True  True  True]

Python passes mutable/immutable objects as references, so function calls make no copy.
def f(x):
    print(id(x))

l = [1,2,3,4]
print(id(l)) # 4901244608
f(l) # 4901244608

def f(x):
    print(id(x))

t = (1,2,3,4)
print(id(t)) # 4902145936
f(t) # 4902145936

View or Shallow Copy
---------------------
Different array objects can share the same data. The view method creates a new array object that looks at the same data.
a = np.array([1,2,3])
print(a.base)                      # None
c = a.view()
print(id(a.base))                  # 4527528432
print(id(a))                       # 4902824016
print(id(c.base))                  # 4902824016
print(id(c))                       # 4902822896

np.base - Base object if memory is from some other object.
like c has the base memory of a in previous example.

a = np.arange(6)
print(a.flags.owndata) # True
c = a.view()
print(id(a)) #4902825456
print(id(c)) #4932942384
print(id(c.base)) # 4932943184

print (c is a) # False
print (c.base is a) # True

#np.flags - Information about the memory layout of the array.
print(c.flags.owndata) # False

c = c.reshape(2,-1)
print(c.shape) # (2, 3)

print(a.shape) # (6,)

c[0,0] = 1234
print(c[0,0]) # 1234

print(a) # [1234    1    2    3    4    5]

SLICING AN ARRAY RETURNS THE VIEW OF IT.
s = a[:]
print(s) # [1234    1    2    3    4    5]
print(a) # [1234    1    2    3    4    5]
s[:] = 10
print(s) # [10 10 10 10 10 10]
print(a) # [10 10 10 10 10 10]

DEEP COPY
=========
The copy method makes a complete copy of the array and its data.

a = np.arange(4)
print(a.base) # None
print(id(a.base)) # 4527528432
print(id(a)) # 4932945360

d = a.copy()
print(d.base) # None
print(id(d.base)) # 4527528432
print(id(d)) # 4920218768

d.base is a  # False - d doesn't share anything with a

d[2] = 10
print(d) # [ 0  1 10  3]
print(a) # [0 1 2 3]

Sometimes copy should be called after slicing if the original array is not required anymore. For example, suppose a is a huge intermediate result and the final result b only contains a small fraction of a, a deep copy should be made when constructing b with slicing:
a = np.arange(1e3)
print(id(a)) # 4932947600
b = a[:100].copy()
print(id(b.base)) # 4527528432
del a # The memory of a can be released

If b = a[:100] is used instead, a is referenced by b and will persist in memory even if del a is executed.

Routines - Functions which are not universal 
----------
In this chapter routine docstrings are presented, grouped by functionality. Many docstrings contain example code, which demonstrates basic usage of the routine. The examples assume that NumPy is imported with:
>>> import numpy as np
A convenient way to execute examples is the %doctest_mode mode of IPython, which allows for pasting of multi-line examples and preserves indentation.

Array creation routines
------------------------
np.arange() - Return evenly spaced values within a given interval.
       Values are generated within the half-open interval [start, stop) (in other words, the interval including start but excluding stop). For integer arguments the function is equivalent to the Python built-in range function, but returns an ndarray rather than a list.

np.array() - Create an array

np.copy() - Create a deep copy of an array. i.e np.copy(a)
ndarray.copy() is preferable. like a.copy() 

np.empty() - Return a new array of given shape and type, without initializing entries i.e with random entries.
       np.empty(6).reshape(2,3)

np.empty_like() - Return a new array with the same shape and type as a given array.

a = np.empty(6).reshape(2,3)
print(a)
b = np.empty_like(a)
print(b)

[[0.000e+00 1.000e+00 2.000e+00]
 [9.997e+03 9.998e+03 9.999e+03]]
[[0.000e+00 1.000e+00 2.000e+00]
 [9.997e+03 9.998e+03 9.999e+03]]

 np.eye() - Return a 2-D array with ones on the diagonal and zeros elsewhere.

 np.fromfile - Construct an array from data in a text or binary file.
A highly efficient way of reading binary data with a known data-type, as well as parsing simply formatted text files. Data written using the tofile method can be read using this function.

np.fromfunction - Construct an array by executing a function over each coordinate.
The resulting array therefore has a value fn(x, y, z) at coordinate (x, y, z).
np.fromfunction(lambda i,j: i*j, (3,3), dtype=int)
array([[0, 0, 0],
       [0, 1, 2],
       [0, 2, 4]])

np.identity - Return the identity array.
The identity array is a square array with ones on the main diagonal.
np.identity(3)

How is it different from np.eye?
np.identity return square array but from np.eye we can get an array of any shape.
np.eye(2,3)
np.identity(3)
np.identity(2,3) # TypeError: Cannot interpret '3' as a data type

np.linspace - Return evenly spaced numbers over a specified interval.
Returns num evenly spaced samples, calculated over the interval [start, stop].
The endpoint of the interval can optionally be excluded.
       np.linspace(2,20,10)

Performace test of linspace and arange and range
%timeit np.linspace(2,200,10) # 32.7 µs ± 402 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
%timeit np.arange(2,201,2) # 935 ns ± 26.7 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
%timeit [i for i in range(2,201,2)]

np.logspace - Return numbers spaced evenly on a log scale.
In linear space, the sequence starts at base ** start (base to the power of start) and ends with base ** stop (see endpoint below).
np.logspace(1,20,10)

np.mgrid - nd_grid instance which returns a dense multi-dimensional “meshgrid”.
An instance of numpy.lib.index_tricks.nd_grid which returns an dense (or fleshed out) mesh-grid when indexed, so that each returned argument has the same shape. The dimensions and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.
However, if the step length is a complex number (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value is inclusive.
       np.mgrid[0:3,0:2]

np.ogrid - nd_grid instance which returns an open multi-dimensional “meshgrid”.
An instance of numpy.lib.index_tricks.nd_grid which returns an open (i.e. not fleshed out) mesh-grid when indexed, so that only one dimension of each returned array is greater than 1. The dimension and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.
However, if the step length is a complex number (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value is inclusive.
       x,y = np.ogrid[:3, :4]
       x@y

np.ones : 
Return a new array of given shape and type, filled with ones.
np.ones([2,3])

np.ones_like() - Return an array of ones with the same shape and type as a given array.
a = np.arange(6).reshape(2,-1)
np.ones_like(a)

np.zeros  - Return a new array of given shape and type, filled with zeros.
np.zeros_like - Return an array of zeros with the same shape and type as a given array.

np.r_ - Translates slice objects to concatenation along the first axis.
This is a simple way to build up arrays quickly. There are two use cases.

If the index expression contains comma separated arrays, then stack them along their first axis.
np.r_[[1,2],[3,4]]

If the index expression contains slice notation or scalars then create a 1-D array with a range indicated by the slice notation.
np.r_[([1,2,3,4,5,6,7][1:5]),[3,4]]

CONVERSIONS:

ndarray.astype(): Change the type of ndarray
a = np.arange(6)
print(a.dtype) # int64
a = a.astype(float)
print(a.dtype) # float64

np.atleast_1d = View each input array into 1-D array
np.atleast_1d(1, [2,4], [[1,2],[3,4]])
[array([1]),
 array([2, 4]),
 array([[1, 2],
        [3, 4]])]

np.atleast_2d = View each input array into 2-D array
np.atleast_2d(1, [2,4], [[1,2],[3,4]])
[array([[1]]),
 array([[2, 4]]),
 array([[1, 2],
        [3, 4]])]

np.atleast_3d(1, [2,4], [[1,2],[3,4]])
[array([[[1]]]),
 array([[[2],
         [4]]]),
 array([[[1],
         [2]],
 
        [[3],
         [4]]])]

np.asmatrix - Convert and array to a matrix.
numpy.mat - create a matrix
asmatrix does not make a copy if the input is already a matrix or an ndarray.
np.asmatrix(np.arange(4).reshape(2,-1))
matrix([[0, 1],
        [2, 3]])

Difference between Numpy arrays and matrices:
Numpy matrices are strictly 2-dimensional, while numpy arrays (ndarrays) are N-dimensional. Matrix objects are a subclass of ndarray, so they inherit all the attributes and methods of ndarrays.

The main advantage of numpy matrices is that they provide a convenient notation for matrix multiplication: if a and b are matrices, then a*b is their matrix product.

On the other hand, as of Python 3.5, NumPy supports infix matrix multiplication using the @ operator, so you can achieve the same convenience of matrix multiplication with ndarrays in Python >= 3.5.

MANIPULATIONS
--------------
np.array_split - Split the arrays into n sub arrays.

np.concatenate - Join a sequence of arrays along an existing axis.
a = np.arange(5)
b = np.arange(5,10)
np.concatenate((a,b))
It is equivalent to - np.stack((a,b)).ravel()
This function will not preserve masking of MaskedArray inputs.
a = np.arange(5)
b = ma.array([10,11,12], mask=[0,1,0])
np.concatenate([a,b])
masked_array(data=[ 0,  1,  2,  3,  4, 10, 11, 12],
             mask=False,
       fill_value=999999)

np.diagonal - returns diagonal elements from a square matrix.
a = np.arange(4).reshape(2,-1)
print(a)
a.diagonal()
[[0 1]
 [2 3]]
array([0, 3])

for a rectangular matrix, it returns diagonal values of square matrix within rectangular matrix.
a = np.arange(6).reshape(2,-1)
print(a)
a.diagonal()
[[0 1 2]
 [3 4 5]]
array([0, 4])

for 3D matrix, it will return diagonals of two 2D matrix.
a = np.arange(8).reshape(2,2,-1)
print(a)
a.diagonal()

[[[0 1]
  [2 3]]
 [[4 5]
  [6 7]]]
array([[0, 6],
       [1, 7]])

How did we get this output?
place two input matrix side by side and fetch the diagonal
[0 1]   [4 5] 
[2 3]   [6 7] 

of these [0,6] and [1,7] are diagonal elements.

It can be applied on Dataframe as below:
df=DataFrame({
    'a':[1,2],
    'b':[3,4]
})
np.diagonal(df)

The anti-diagonal can be obtained by reversing the order of elements using either numpy.flipud or numpy.fliplr.

a = np.arange(4).reshape(2,2)
print(a)
np.fliplr(a).diagonal() # array([1, 2]) # Horizontal flip
np.flipud(a).diagonal() # array([2, 1]) # Vertical flip

np.fliplr - Flip array in left/right direction, Input array, must be at least 2-D.
a = np.arange(4).reshape(2,-1)
print(a)
np.fliplr(a)
[[0 1]
 [2 3]]
array([[1, 0],
       [3, 2]])

np.flipud - Flip array in the up/down direction.
a = np.arange(4).reshape(2,-1)
print(a)
np.flipud(a)
[[0 1]
 [2 3]]
array([[2, 3],
       [0, 1]])

np.rot90 - rotate the array 90
a = np.arange(4).reshape(2,-1)
print(a)
np.rot90(a)

[[0 1]
 [2 3]]
array([[1, 3],
       [0, 2]])

np.flip - Reverse the order of elements in an array along the given axis.
a = np.arange(4).reshape(2,-1)
print(a)
np.flip(a)

[[0 1]
 [2 3]]
array([[3, 2],
       [1, 0]])

np.diag - create an array with diagonal elements.
np.diag([2,2])
array([[2, 0],
       [0, 2]])
it is equivalent to
(np.eye(2)*2).astype(int)

ndarray.item() - get the item from an array based on index.

np.random.seed(3)
np.random.seed(3)
x = np.random.randint(9, size=(3,3))
print(x)
x.item((2,1)) # 5

[[8 3 8]
 [8 0 5]
 [3 5 7]]
5

np.newaxis - A convenient alias for None, useful for indexing arrays.
np.newaxis is None
x = np.array([1,2,3])
x[:, np.newaxis]
x[:, np.newaxis] * x

np.repeat - Repeat elements of an array.
np.repeat(3,4)
array([3, 3, 3, 3])

np.repeat(np.arange(4).reshape(2,-1), 2, axis=1)
array([[0, 0, 1, 1],
       [2, 2, 3, 3]])

np.repeat(np.arange(4).reshape(2,-1), [2,3], axis=0)
array([[0, 1],
       [0, 1],
       [2, 3],
       [2, 3],
       [2, 3]])

================
Masked Arrays:
================
Rationale
Masked arrays are arrays that may have missing or invalid entries. The numpy.ma module provides a nearly work-alike replacement for numpy that supports data arrays with masks.

What is a masked array?
In many circumstances, datasets can be incomplete or tainted by the presence of invalid data. For example, a sensor may have failed to record a data, or recorded an invalid value. The numpy.ma module provides a convenient way to address this issue, by introducing masked arrays.

A masked array is the combination of a standard numpy.ndarray and a mask. A mask is either nomask, indicating that no value of the associated array is invalid, or an array of booleans that determines for each element of the associated array whether the value is valid or not. When an element of the mask is False, the corresponding element of the associated array is valid and is said to be unmasked. When an element of the mask is True, the corresponding element of the associated array is said to be masked (invalid).

The package ensures that masked entries are not used in computations.
As an illustration, let’s consider the following dataset:

x = np.array([1,2,3,-1,5])
print(x.mean()) # 2.0 wrong output because of invalid entry in dataset
mx = ma.masked_array(x, mask=[0,0,0,1,0])
mx.mean() # 2.75 correct ouput after masking x as mx

The numpy.ma module
The main feature of the numpy.ma module is the MaskedArray class, which is a subclass of numpy.ndarray.

To create an array with the second element invalid, we would do:
ma.array([1,2,3], mask=[0,1,0])

To create a masked array where all values close to 1.e20 are invalid, we would do:
ma.masked_values([1.0,1.e20, 3.0,4.0], 1.e20)
We can find the sum of unmasked values as:
z = ma.masked_values([1.0, 1.e20, 3.0, 4.0], 1.e20).sum()

Constructing masked arrays
There are several ways to construct a masked array.

A first possibility is to directly invoke the MaskedArray class.

array(data[, dtype, copy, order, mask, …])  --> An array class with possibly masked values.
a = np.array([10,20,30])
ma.array(a, mask=[0,1,0])

A second possibility is to use the two masked array constructors, array and masked_array.

masked_array --> alias of numpy.ma.core.MaskedArray
a = np.array([10,20,30])
ma.masked_array(a, mask=[0,1,0])

There are many other methods to create masked array from a given array:
a = np.arange(10)
# you want to find mean of first 5 values
ma.masked_where(a>=5, a).mean()

Methods:
asarray(a[, dtype, order]) --> Convert the input to a masked array of the given data-type.

asanyarray(a[, dtype]) --> Convert the input to a masked array, conserving subclasses.

fix_invalid(a[, mask, copy, fill_value]) --> Return input with invalid data masked and replaced by a fill value.

masked_equal(x, value[, copy]) --> Mask an array where equal to a given value.

masked_greater(x, value[, copy]) --> Mask an array where greater than a given value.

masked_greater_equal(x, value[, copy]) --> Mask an array where greater than or equal to a given value.

masked_inside(x, v1, v2[, copy]) --> Mask an array inside a given interval.

masked_invalid(a[, copy]) --> Mask an array where invalid values occur (NaNs or infs).

masked_less(x, value[, copy]) --> Mask an array where less than a given value.

masked_less_equal(x, value[, copy]) --> Mask an array where less than or equal to a given value.

masked_not_equal(x, value[, copy]) --> Mask an array where not equal to a given value.

masked_object(x, value[, copy, shrink]) --> Mask the array x where the data are exactly equal to value.

masked_outside(x, v1, v2[, copy]) --> Mask an array outside a given interval.

masked_values(x, value[, rtol, atol, copy, …]) --> Mask using floating point equality.

masked_where(condition, a[, copy]) --> Mask an array where a condition is met.

Accessing the data
The underlying data of a masked array can be accessed in several ways:

through the data attribute -->  The output is a view of the array as a numpy.ndarray or one of its subclasses, depending on the type of the underlying data at the masked array creation.
To get all entries of a masked array
a = np.arange(10)
ma.masked_array(a).data # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

through the __array__ method -->  The output is then a numpy.ndarray.
a = np.arange(10)
ma.masked_array(a).__array__() # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

by directly taking a view of the masked array as a numpy.ndarray or one of its subclass (which is actually what using the data attribute does).
BY USING THE getdata FUNCTION.

Accessing only the valid entries
To retrieve only the valid entries, we can use the inverse of the mask as an index. The inverse of the mask can be calculated with the numpy.logical_not function or simply with the ~ operator:
a = np.arange(10)
m = ma.masked_less_equal(a, 5)
m[~m.mask]
# masked_array(data=[6, 7, 8, 9],
#             mask=[False, False, False, False],
#       fill_value=999999)

Another way to retrieve the valid data is to use the compressed method, which returns a one-dimensional ndarray (or one of its subclasses, depending on the value of the baseclass attribute):
Note that the output of compressed is always 1D.
m.compressed() # array([6, 7, 8, 9])

None of these methods is completely satisfactory if some entries have been marked as invalid. As a general rule, where a representation of the array is required without any masked entries, it is recommended to fill the array with the filled method.

Accessing the mask
The mask of a masked array is accessible through its mask attribute. We must keep in mind that a True entry in the mask indicates an invalid data.

Another possibility is to use the getmask and getmaskarray functions. getmask(x) outputs the mask of x if x is a masked array, and the special value nomask otherwise. getmaskarray(x) outputs the mask of x if x is a masked array. If x has no invalid entry or is not a masked array, the function outputs a boolean array of False with as many elements as x

Modifying the mask
Masking an entry
The recommended way to mark one or several specific entries of a masked array as invalid is to assign the special value masked to them:

x = np.array([1, 2, 3])
m = ma.array(x)
m[0] = ma.masked
m
masked_array(data=[--, 2, 3],
             mask=[ True, False, False],
       fill_value=999999)

y = ma.masked_array(np.arange(9).reshape(3,-1))
y[(0,1,2),(1,2,0)] = ma.masked
y

masked_array(
  data=[[0, --, 2],
        [3, 4, --],
        [--, 7, 8]],
  mask=[[False,  True, False],
        [False, False,  True],
        [ True, False, False]],
  fill_value=999999)

  z = ma.array([1, 2, 3, 4])
  z[:-2] = ma.masked

A second possibility is to modify the mask directly, but this usage is discouraged.
Note
When creating a new masked array with a simple, non-structured datatype, the mask is initially set to the special value nomask, that corresponds roughly to the boolean False. Trying to set an element of nomask will fail with a TypeError exception, as a boolean does not support item assignment.

All the entries of an array can be masked at once by assigning True to the mask:
>>> x = ma.array([1, 2, 3], mask=[0, 0, 1])
>>> x.mask = True
>>> x

Finally, specific entries can be masked and/or unmasked by assigning to the mask a sequence of booleans:
>>> x = ma.array([1, 2, 3])
>>> x.mask = [0, 1, 0]
>>> x

Unmasking an entry
To unmask one or several specific entries, we can just assign one or several new valid values to them:
>>> x = ma.array([1, 2, 3], mask=[0, 0, 1])
>>> x
masked_array(data=[1, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> x[-1] = 5
>>> x
masked_array(data=[1, 2, 5],
             mask=[False, False, False],
       fill_value=999999)

Unmasking an entry by direct assignment will silently fail if the masked array has a hard mask, as shown by the hardmask attribute. This feature was introduced to prevent overwriting the mask. To force the unmasking of an entry where the array has a hard mask, the mask must first to be softened using the soften_mask method before the allocation. It can be re-hardened with harden_mask:

If the mask is hard, it cannot be modified.

a = ma.array(np.arange(4), mask=[0,0,1,0], hard_mask=True)
a
a[-2] = 20 ## Nothing changed after this

a.soften_mask()
a[-2] = 20
a  ## value of a[-2] has been changed to 20
a.harden_mask()


To unmask all masked entries of a masked array (provided the mask isn’t a hard mask), the simplest solution is to assign the constant nomask to the mask:
a = ma.array(np.arange(4), mask=[0,0,1,0])
a.mask = ma.nomask
a

Indexing and slicing
As a MaskedArray is a subclass of numpy.ndarray, it inherits its mechanisms for indexing and slicing.

When accessing a single entry of a masked array with no named fields, the output is either a scalar (if the corresponding entry of the mask is False) or the special value masked (if the corresponding entry of the mask is True):

a = ma.array(np.arange(4), mask=[0,0,1,0])
a[1] # 1
a[2] # masked
a[2] is ma.masked ## True

If the masked array has named fields, accessing a single entry returns a numpy.void object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.

a = ma.array(np.arange(4).reshape(2,-1), mask=[(0,0), (0,1)])
a[0] # data=[0, 1]
a[1] # data=[2, --]
a[1,1] # masked


a = ma.array(np.arange(1,6), mask=[0,1,0,0,1])
a[1:3] # data=[--, 3],
a.data # array([1, 2, 3, 4, 5])
a.mask # array([False,  True, False, False,  True])
a.compressed() # array([1, 3, 4])

Operations on masked arrays
Arithmetic and comparison operations are supported by masked arrays. As much as possible, invalid entries of a masked array are not processed, meaning that the corresponding data entries should be the same before and after the operation.

Warning
We need to stress that this behavior may not be systematic, that masked data may be affected by the operation in some cases and therefore users should not rely on this data remaining unchanged.

The numpy.ma module comes with a specific implementation of most ufuncs. Unary and binary functions that have a validity domain (such as log or divide) return the masked constant whenever the input is masked or falls outside the validity domain:

>>> ma.log([-1, 0, 1, 2])
masked_array(data=[--, --, 0.0, 0.6931471805599453],

Masked arrays also support standard numpy ufuncs. The output is then a masked array. The result of a unary ufunc is masked wherever the input is masked. The result of a binary ufunc is masked wherever any of the input is masked. If the ufunc also returns the optional context output (a 3-element tuple containing the name of the ufunc, its arguments and its domain), the context is processed and entries of the output masked array are masked wherever the corresponding input fall outside the validity domain:

>>> x = ma.array([-1, 1, 0, 2, 3], mask=[0, 0, 0, 0, 1])
>>> np.log(x)
masked_array(data=[--, 0.0, --, 0.6931471805599453, --],

Data with a given value representing missing data
Let’s consider a list of elements, x, where values of -9999. represent missing data. We wish to compute the average value of the data and the vector of anomalies (deviations from the average):

a = ma.concatenate((ma.arange(1,5), ma.array([999])))
a[-1] = ma.masked
a.mean()
print(a-a.mean())

Filling in the missing data
Suppose now that we wish to print that same data, but with the missing values replaced by the average value.
print(a.filled(a.mean()))

Numerical operations
Numerical operations can be easily performed without worrying about missing values, dividing by zero, square roots of negative numbers, etc.:
>>> import numpy.ma as ma
>>> x = ma.array([1., -1., 3., 4., 5., 6.], mask=[0,0,0,0,1,0])
>>> y = ma.array([1., 2., 0., 4., 5., 6.], mask=[0,0,0,0,0,1])
>>> print(ma.sqrt(x/y))
[1.0 -- -- 1.0 -- --]

Ignoring extreme values
Let’s consider an array d of floats between 0 and 1. We wish to compute the average of the values of d while ignoring any data outside the range [0.2, 0.9]:

>>> d = np.linspace(0, 1, 20)
>>> print(d.mean() - ma.masked_outside(d, 0.2, 0.9).mean())
-0.05263157894736836

d = np.arange(10)
d.mean() # 4.5
ma.masked_outside(d,5,8).mean() # 6.5

np.resize - Return a new array with the specified shape.
If the new array is larger than the original array, then the new array is filled with repeated copies of a. Note that this behavior is different from a.resize(new_shape) which fills with zeros instead of repeated copies of a.
a = np.arange(4)
np.resize(a,3) # array([0, 1, 2])
a= np.arange(6).reshape(2,-1)
print(a)
np.resize(a,[2,5])
[[0 1 2]
 [3 4 5]]
array([[0, 1, 2, 3, 4],
       [5, 0, 1, 2, 3]])

np.swapaxes  - Interchange two axes of an array.
a = np.arange(6).reshape(2,-1)
print(a)
np.swapaxes(a,1,0)
[[0 1 2]
 [3 4 5]]
array([[0, 3],
       [1, 4],
       [2, 5]])




