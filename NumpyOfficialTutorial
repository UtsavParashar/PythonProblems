NumpyOfficialTutorial
---------------------

ndarray - 
==========
NumPy’s array class is called ndarray. It is also known by the alias array. Note that numpy.array is not the same as the Standard Python Library class array.array, which only handles one-dimensional arrays and offers less functionality. The more important attributes of an ndarray object are:

a = np.arange(20).reshape(5,4)
print(a.ndim) # 2
print(a.shape) # (5,4)
print(a.size) # 20
print(a.dtype) # int64
print(a.itemsize) # 8, size of each item in a array in byte
print(a.data) # 0x126b50520 - Memory location
print(type(a)) # <class 'numpy.ndarray'>

Array Creation
==============
There are several ways to create arrays.
For example, you can create an array from a regular Python list or tuple using the array function. The type of the resulting array is deduced from the type of the elements in the sequences.
>>> import numpy as np
>>> a = np.array([2, 3, 4])

A frequent error consists in calling array with multiple arguments, rather than providing a single sequence as an argument.
>>> a = np.array(1, 2, 3, 4)    # WRONG
TypeError: array() takes from 1 to 2 positional arguments but 4 were given

array transforms sequences of sequences into two-dimensional arrays, sequences of sequences of sequences into three-dimensional arrays, and so on.
a = np.array([[1,1,[2,3]], [2,[2,4],3], [[3,1],3,4]], dtype='object')
a.shape # (3, 3)
(If we want to create an array of more than 2D then dtype needs to be specified.)

Often, the elements of an array are originally unknown, but its size is known. Hence, NumPy offers several functions to create arrays with initial placeholder content. These minimize the necessity of growing arrays, an expensive operation.

The function zeros creates an array full of zeros, the function ones creates an array full of ones, and the function empty creates an array whose initial content is random and depends on the state of the memory. By default, the dtype of the created array is float64, but it can be specified via the key word argument dtype.

np.zeros([2,2])
array([[0., 0.],
       [0., 0.]])

np.ones((3,3), dtype=np.int16)
array([[1, 1, 1],
       [1, 1, 1],
       [1, 1, 1]], dtype=int16)

np.empty([2,2])
array([[0.0e+000, 4.9e-324],
       [9.9e-324, 1.5e-323]])

arange - 
To create sequences of numbers, NumPy provides the arange function which is analogous to the Python built-in range, but returns an array.
>>> np.arange(0, 2, 0.3)  # it accepts float arguments
array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])

linspace:
When arange is used with floating point arguments, it is generally not possible to predict the number of elements obtained, due to the finite floating point precision. For this reason, it is usually better to use the function linspace that receives as an argument the number of elements that we want, instead of the step:
np.linspace(0,2,9)

Printing Arrays
One-dimensional arrays are then printed as rows, bidimensionals as matrices and tridimensionals as lists of matrices.
3-D array as list of 2D array
If we want to a 3D array with two 2D array then
np.arange(24).reshape(2,3,4)

If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners:
np.arange(100000) # array([    0,     1,     2, ..., 99997, 99998, 99999])
np.arange(10000).reshape(100,100)

To disable this behaviour and force NumPy to print the entire array, you can change the printing options using set_printoptions.
>>> np.set_printoptions(threshold=sys.maxsize)

Unlike in many matrix languages, the product operator * operates elementwise in NumPy arrays. The matrix product can be performed using the @ operator (in python >=3.5) or the dot function or method:
a = np.array([[1,1],[0,1]])
b = np.array([[2,0],[3,4]])
a*b
array([[2, 0],
       [0, 4]])
a @ b
array([[5, 4],
       [3, 4]])
a.dot(b)
array([[5, 4],
       [3, 4]])

Some operations, such as += and *=, act in place to modify an existing array rather than create a new one.
rg = np.random.default_rng(1) ## create instance of default random number generator
a = np.ones([2,3], dtype=int)
b = rg.random([2,3])
a *= 3
array([[3, 3, 3],
       [3, 3, 3]])
b += a
array([[3.51182162, 3.9504637 , 3.14415961],
       [3.94864945, 3.31183145, 3.42332645]])

a += b # b is not automatically converted to integer type
UFuncTypeError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'

When operating with arrays of different types, the type of the resulting array corresponds to the more general or precise one (a behavior known as upcasting).

a = np.ones(3, dtype=np.int32)
b = np.linspace(0, np.pi, 3)
b.dtype.name # 'float64'
a.dtype.name # 'int32'
c = a + b
c.dtype.name # 'float64'
d = np.exp(c*1j)
d.dtype.name # 'complex128'

Many unary operations, such as computing the sum of all the elements in the array, are implemented as methods of the ndarray class.

a = rg.random((2,3))
a.sum() # 2.412
a.max() # 0.980
a.min() # 0.160
a.mean() # 0.593
a.var() # 0.0829
a.std() # 0.329

By default, these operations apply to the array as though it were a list of numbers, regardless of its shape. However, by specifying the axis parameter you can apply an operation along the specified axis of an array:
b = np.arange(6).reshape(2,3)
print(b)
b.sum(axis=1) # sum of each row
b.sum(axis=0) # sum of each column
b.cumsum(axis=0) # cumulative sum of each 
[[0 1 2]
 [3 4 5]]
array([[0, 1, 2],
       [3, 5, 7]])

NumPy provides familiar mathematical functions such as sin, cos, and exp. In NumPy, these are called “universal functions” (ufunc). Within NumPy, these functions operate elementwise on an array, producing an array as output.

b = np.arange(3) # array([0, 1, 2])
print(b)
np.exp(b) # array([1.        , 2.71828183, 7.3890561 ])
np.sqrt(b) # array([0.        , 1.        , 1.41421356])
c = np.array([2., -1., 4.])
print('*'*10)
print(c)
print('*'*10)
np.add(b,c) # array([2., 0., 6.])
np.all(b) # False
np.any(b) # True
d = np.array([[9 ,11, 2], [1, 6, 8]])
print(d)

# Apply a function to 1-D slices along the given axis.
np.apply_along_axis(lambda x: (x[0] + x[-1])*.5 , 1, d )  # array([2., 8.])
# np.apply_over_axes  ## Apply the function over multiple axis

np.argmax(d) # 1  -- return the max index
np.argmin(d) # 3  -- return the max index
np.max(d) # 11    -- returns max value

np.argsort(d) ## get the index of the elements as per sorted list

np.average(np.arange(1, 5), weights=np.arange(4)) # 3.33 ## Returns weighted average
px = np.array([19,19.10,21,20.05])
vol = np.array([100,110, 10000, 110000])
np.average(px, weights=vol)

# occurence of each element in an array 
np.bincount([1,2,1,2,1,4]) #  array([0, 3, 2, 0, 1])

np.ceil(4.05) # 5

numpy.clip(a, a_min, a_max, out=None, **kwargs)[source]
Clip (limit) the values in an array.
Given an interval, values outside the interval are clipped to the interval edges. For example, if an interval of [0, 1] is specified, values smaller than 0 become 0, and values larger than 1 become 1.

np.clip(np.arange(10), a_min=1, a_max=8) # array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])

np.corrcoef - Return Pearson product-moment correlation coefficients.
rg = np.random.default_rng(seed=42)
xarr = rg.random((3, 3))
np.corrcoef(xarr)

np.cov - Estimate a covariance matrix, given data and weights.

np.cross - Return the cross product of two (arrays of) vectors.
np.cross(np.arange(1,4), np.arange(2,5))

np.cumprd - Return the cumulative product of elements along a given axis.
np.cumprod(np.arange(1,6))[-1] # to get the factorial

np.cumsum - Return the cumulative sum of the elements along a given axis.
np.cumsum(np.arange(1,6)) # array([ 1,  3,  6, 10, 15])

np.diff - Calculate the n-th discrete difference along the given axis.
The first difference is given by out[i] = a[i+1] - a[i] along the given axis, higher differences are calculated by using diff recursively.
np.diff(np.arange(5)) # array([1, 1, 1, 1])

numpy.dot(a, b, out=None) - Dot product of two arrays. Specifically,
x, y = np.ogrid[:3, :4]
x @ y
x.dot(y)

np.floor - Return the floor of the input, element-wise.

np.inner - product and sum of all elements of two arrays
np.inner(np.arange(1,3), np.arange(1,3)) # 5

np.invert - Compute bit-wise inversion, or bit-wise NOT, element-wise.
np.bitwise_not is np.invert # True
np.invert([2]) # array([-3])
np.invert(-1*np.arange(5)) # array([-1, -2, -3, -4, -5])
np.invert([True, False]) # array([False,  True])

np.lexsort - Perform an indirect stable sort using a sequence of keys.
names = ('Ramesh', 'Suresh', 'Chandu')
surname = ('Ray', 'Cur', 'Shu')
[surname[i] + "," + names[i] for i in np.lexsort((names, surname))]

np.maximum - Maximum value across each element in two arrays
np.maximum([1,5,3], [2,3,4]) # array([2, 5, 4])

np.mean(np.arange(1,6)) # 3.0
np.median(np.arange(6,1,-1)) # 4.0

np.minimum([1,5,3], [2,3,4]) # array([1, 3, 3])

np.nonzero - Return the indices of the elements that are non-zero.
np.nonzero([0,1,0,1,0,2,0,21.]) # (array([1, 3, 5, 7]),)

np.outer - Compute the outer product of two vectors.
np.outer(np.arange(1,3), np.arange(3,5))
array([[3, 4],
       [6, 8]])

np.prod - Return the product of array elements over a given axis.
np.prod(np.arange(1,6)) # 120, factorial

np.re - regular expression

np.round - round off the number
np.round([1.3, 1.5]) # array([1., 2.])

np.sort - Return a sorted copy of an array.
np.sort(np.arange(10,1,-2)) # array([ 2,  4,  6,  8, 10])

np.std(np.arange(1,5)) # 1.118
np.var(np.arange(1,5)) # 1.25

np.sum(np.arange(1,11)) # 55

np.trace - add diagonals of an array
np.trace(np.eye(3)) # 3.0
np.trace(np.arange(1,10).reshape(3,3))

np.transpose(np.arange(1,7).reshape(2,3))

np.vdot - Return the dot product of two vectors.
np.vdot(np.arange(1,5).reshape(2,2), np.arange(1,5).reshape(2,2)) # 30

Broadcasting in Numpy:
----------------------
Advanced Concept in Numpy to perform operations of numpy.
The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is “broadcast” across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are, however, cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation
Rules:
1. arrays of same length can be added, subtracted, multiplied etc
       print(np.arange(1,5) + np.arange(1,5))
2. arrays can be multiplied by a scaler.
       print(np.arange(1,5) * 2)
3. 2D array and 1D array can be multiplied if number of elements in 1D array equals number of columns in 2D array.
       print(np.arange(9).reshape(3,3) + np.arange(1,4))
4. transposed arrays of same length can be multiplied.
       a = np.array([0, 10, 20, 30])
       b = np.array([1., 2., 3.])
       a[:, np.newaxis] + b


np.vectorize:
GENERALIZED FUNCTION CLASS.
Define a vectorized function which takes a nested sequence of objects or numpy arrays as inputs and returns a single numpy array or a tuple of numpy arrays. The vectorized function evaluates pyfunc over successive tuples of the input arrays like the python map function, except it uses the broadcasting rules of numpy.

The vectorize function is provided primarily for convenience, not for performance. The implementation is essentially a for loop.

def myfunc(a,b):
    return a-b if a>b else b-a

vfunc = np.vectorize(myfunc)
vfunc(np.array([100, 90, 80, 70]),10)

np.where:
numpy.where(condition[, x, y])
Return elements chosen from x or y depending on condition.

When only condition is provided, this function is a shorthand for np.asarray(condition).nonzero(). Using nonzero directly should be preferred, as it behaves correctly for subclasses. The rest of this documentation covers only the case where all three arguments are provided.
If all the arrays are 1-D, where is equivalent to:

[xv if c else yv for c, xv, yv in zip(condition, x, y)]

a = np.arange(10)
np.where(a>3, a, a*10)

Indexing, Slicing and Iterating
--------------------------------
One-dimensional arrays can be indexed, sliced and iterated over, much like lists and other Python sequences.

a = np.arange(10)**3
a # array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])

a[2]
a[:6:2]
for i in a:
    print(i**(1/3))

np.fromfunction: Construct an array by executing a function over each coordinate(index).
np.fromfunction(lambda i,j: i+j, (3,3), dtype=int)
array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])
It is adding the index 0,0 , 0,1 etc

np.fromfunction(lambda i,j: i==j, (3,3), dtype=int)
array([[ True, False, False],
       [False,  True, False],
       [False, False,  True]])

Multidimensional arrays can have one index per axis. These indices are given in a tuple separated by commas:

b = np.fromfunction(lambda i,j:10*i+j, (5,4), dtype=int)
print(b)
b[2,3]
b[0:4, 1] # # each row in the second column of b

When fewer indices are provided than the number of axes, the missing indices are considered complete slices:
b[-1] # array([40, 41, 42, 43])

The expression within brackets in b[i] is treated as an i followed by as many instances of : as needed to represent the remaining axes. NumPy also allows you to write this using dots as b[i, ...].

The dots (...) represent as many colons as needed to produce a complete indexing tuple. For example, if x is an array with 5 axes, then

x[1, 2, ...] is equivalent to x[1, 2, :, :, :],
x[..., 3] to x[:, :, :, :, 3] and
x[4, ..., 5, :] to x[4, :, :, 5, :].

b[1,...] # array([10, 11, 12, 13])

Iterating over multidimensional arrays is done with respect to the first axis:
for row in b:
    print(row*10)

However, if one wants to perform an operation on each element in the array, one can use the flat attribute which is an iterator over all the elements of the array:
for element in b.flat:
    print(element)

SHAPE MANIPULATION
------------------
Changing the shape of an array
An array has a shape given by the number of elements along each axis:

rg = np.random.default_rng(seed=42)
a = np.floor(10*rg.random((3,4)))
a.shape

The shape of an array can be changed with various commands. Note that the following three commands all return a modified array, but do not change the original array:

a.ravel() # array([7., 4., 8., 6., 0., 9., 7., 7., 1., 4., 3., 9.])
# returns the array, flattened  - similar to raze in kdb

a.reshape(2,6) # # returns the array with a modified shape

a.T # # returns the array, transposed

The order of the elements in the array resulting from ravel is normally “C-style”, that is, the rightmost index “changes the fastest”, so the element after a[0, 0] is a[0, 1]. If the array is reshaped to some other shape, again the array is treated as “C-style”. NumPy normally creates arrays stored in this order, so ravel will usually not need to copy its argument, but if the array was made by taking slices of another array or created with unusual options, it may need to be copied. The functions ravel and reshape can also be instructed, using an optional argument, to use FORTRAN-style arrays, in which the leftmost index changes the fastest.

The reshape function returns its argument with a modified shape, whereas the ndarray.resize method modifies the array itself:

a.shape # (3, 4)
a.resize(4,3)
a.shape # (4, 3)

If a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated:
a.reshape(6,-1) 
In this case you need no do the math that I want to convert a 4*3 matrix into 6*2, you just give 6,-1, the reshape method will do the math for you and provide an array of 6 rows and 2 columns

STACKING TOGETHER DIFFERENT ARRAYS -- APPENDING ARRAYS
----------------------------------- 
Several arrays can be stacked together along different axes:
Arrays can be appended horizontally and vertically.
a = np.arange(4).reshape(2,-1)
b = np.arange(5,9).reshape(2,-1)
np.vstack((a,b))
array([[0, 1],
       [2, 3],
       [5, 6],
       [7, 8]])
np.hstack((a,b))
array([[0, 1, 5, 6],
       [2, 3, 7, 8]])

Eg with single dimentional array
a = np.arange(5)
b = np.arange(5)
np.vstack((a,b))
array([[0, 1, 2, 3, 4],
       [0, 1, 2, 3, 4]])

np.hstack((a,b))
array([0, 1, 2, 3, 4, 0, 1, 2, 3, 4])

The function column_stack stacks 1D arrays as columns into a 2D array. It is equivalent to hstack only for 2D arrays:
a = np.arange(5)
b = np.arange(5,10)
np.column_stack((a,b))
array([[0, 5],
       [1, 6],
       [2, 7],
       [3, 8],
       [4, 9]])
a = np.arange(5)
b = np.arange(5,10)
np.row_stack((a,b))
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])

On the other hand, the function row_stack is equivalent to vstack for any input arrays. In fact, row_stack is an alias for vstack:
np.row_stack is np.vstack # True

Note
In complex cases, r_ and c_ are useful for creating arrays by stacking numbers along one axis. They allow the use of range literals :
np.r_[1:4,11,22] # array([ 1,  2,  3, 11, 22])
np.c_[1:4,1:4]
       array([[1, 1],
       [2, 2],
       [3, 3]])
When used with arrays as arguments, r_ and c_ are similar to vstack and hstack in their default behavior, but allow for an optional argument giving the number of the axis along which to concatenate.

SPLITTING ONE ARRAY INTO SEVERAL SMALLER ONES - SEGREGATING ARRAYS
-------------------------------------------------------------------
np.hsplit and np.vsplit
Using hsplit, you can split an array along its horizontal axis, either by specifying the number of equally shaped arrays to return, or by specifying the columns after which the division should occur:
vsplit splits along the vertical axis, and array_split allows one to specify along which axis to split.

a = np.arange(16).reshape(4,-1)
np.hsplit(a, 2)
np.vsplit(a,2)

COPIES AND VIEWS
----------------
Copies and Views
When operating and manipulating arrays, their data is sometimes copied into a new array and sometimes not. This is often a source of confusion for beginners. There are three cases:

NO COPY AT ALL
---------------
Simple assignments make no copy of objects or their data.
a = np.arange(5)
b = a
print(id(a)) # 4902824816
print(id(b)) # 4902824816
print(a is b) # True
print(a == b) # [ True  True  True  True  True]

Python passes mutable/immutable objects as references, so function calls make no copy.
def f(x):
    print(id(x))

l = [1,2,3,4]
print(id(l)) # 4901244608
f(l) # 4901244608

def f(x):
    print(id(x))

t = (1,2,3,4)
print(id(t)) # 4902145936
f(t) # 4902145936

View or Shallow Copy
---------------------
Different array objects can share the same data. The view method creates a new array object that looks at the same data.
a = np.array([1,2,3])
print(a.base)                      # None
c = a.view()
print(id(a.base))                  # 4527528432
print(id(a))                       # 4902824016
print(id(c.base))                  # 4902824016
print(id(c))                       # 4902822896

np.base - Base object if memory is from some other object.
like c has the base memory of a in previous example.

a = np.arange(6)
print(a.flags.owndata) # True
c = a.view()
print(id(a)) #4902825456
print(id(c)) #4932942384
print(id(c.base)) # 4932943184

print (c is a) # False
print (c.base is a) # True

#np.flags - Information about the memory layout of the array.
print(c.flags.owndata) # False

c = c.reshape(2,-1)
print(c.shape) # (2, 3)

print(a.shape) # (6,)

c[0,0] = 1234
print(c[0,0]) # 1234

print(a) # [1234    1    2    3    4    5]

SLICING AN ARRAY RETURNS THE VIEW OF IT.
s = a[:]
print(s) # [1234    1    2    3    4    5]
print(a) # [1234    1    2    3    4    5]
s[:] = 10
print(s) # [10 10 10 10 10 10]
print(a) # [10 10 10 10 10 10]

DEEP COPY
=========
The copy method makes a complete copy of the array and its data.

a = np.arange(4)
print(a.base) # None
print(id(a.base)) # 4527528432
print(id(a)) # 4932945360

d = a.copy()
print(d.base) # None
print(id(d.base)) # 4527528432
print(id(d)) # 4920218768

d.base is a  # False - d doesn't share anything with a

d[2] = 10
print(d) # [ 0  1 10  3]
print(a) # [0 1 2 3]

Sometimes copy should be called after slicing if the original array is not required anymore. For example, suppose a is a huge intermediate result and the final result b only contains a small fraction of a, a deep copy should be made when constructing b with slicing:
a = np.arange(1e3)
print(id(a)) # 4932947600
b = a[:100].copy()
print(id(b.base)) # 4527528432
del a # The memory of a can be released

If b = a[:100] is used instead, a is referenced by b and will persist in memory even if del a is executed.

Routines - Functions which are not universal 
----------
In this chapter routine docstrings are presented, grouped by functionality. Many docstrings contain example code, which demonstrates basic usage of the routine. The examples assume that NumPy is imported with:
>>> import numpy as np
A convenient way to execute examples is the %doctest_mode mode of IPython, which allows for pasting of multi-line examples and preserves indentation.

Array creation routines
------------------------
np.arange() - Return evenly spaced values within a given interval.
       Values are generated within the half-open interval [start, stop) (in other words, the interval including start but excluding stop). For integer arguments the function is equivalent to the Python built-in range function, but returns an ndarray rather than a list.

np.array() - Create an array

np.copy() - Create a deep copy of an array. i.e np.copy(a)
ndarray.copy() is preferable. like a.copy() 

np.empty() - Return a new array of given shape and type, without initializing entries i.e with random entries.
       np.empty(6).reshape(2,3)

np.empty_like() - Return a new array with the same shape and type as a given array.

a = np.empty(6).reshape(2,3)
print(a)
b = np.empty_like(a)
print(b)

[[0.000e+00 1.000e+00 2.000e+00]
 [9.997e+03 9.998e+03 9.999e+03]]
[[0.000e+00 1.000e+00 2.000e+00]
 [9.997e+03 9.998e+03 9.999e+03]]

 np.eye() - Return a 2-D array with ones on the diagonal and zeros elsewhere.

 np.fromfile - Construct an array from data in a text or binary file.
A highly efficient way of reading binary data with a known data-type, as well as parsing simply formatted text files. Data written using the tofile method can be read using this function.

np.fromfunction - Construct an array by executing a function over each coordinate.
The resulting array therefore has a value fn(x, y, z) at coordinate (x, y, z).
np.fromfunction(lambda i,j: i*j, (3,3), dtype=int)
array([[0, 0, 0],
       [0, 1, 2],
       [0, 2, 4]])

np.identity - Return the identity array.
The identity array is a square array with ones on the main diagonal.
np.identity(3)

How is it different from np.eye?
np.identity return square array but from np.eye we can get an array of any shape.
np.eye(2,3)
np.identity(3)
np.identity(2,3) # TypeError: Cannot interpret '3' as a data type

np.linspace - Return evenly spaced numbers over a specified interval.
Returns num evenly spaced samples, calculated over the interval [start, stop].
The endpoint of the interval can optionally be excluded.
       np.linspace(2,20,10)

Performace test of linspace and arange and range
%timeit np.linspace(2,200,10) # 32.7 µs ± 402 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
%timeit np.arange(2,201,2) # 935 ns ± 26.7 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
%timeit [i for i in range(2,201,2)]

np.logspace - Return numbers spaced evenly on a log scale.
In linear space, the sequence starts at base ** start (base to the power of start) and ends with base ** stop (see endpoint below).
np.logspace(1,20,10)

np.mgrid - nd_grid instance which returns a dense multi-dimensional “meshgrid”.
An instance of numpy.lib.index_tricks.nd_grid which returns an dense (or fleshed out) mesh-grid when indexed, so that each returned argument has the same shape. The dimensions and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.
However, if the step length is a complex number (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value is inclusive.
       np.mgrid[0:3,0:2]

np.ogrid - nd_grid instance which returns an open multi-dimensional “meshgrid”.
An instance of numpy.lib.index_tricks.nd_grid which returns an open (i.e. not fleshed out) mesh-grid when indexed, so that only one dimension of each returned array is greater than 1. The dimension and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.
However, if the step length is a complex number (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value is inclusive.
       x,y = np.ogrid[:3, :4]
       x@y

np.ones : 
Return a new array of given shape and type, filled with ones.
np.ones([2,3])

np.ones_like() - Return an array of ones with the same shape and type as a given array.
a = np.arange(6).reshape(2,-1)
np.ones_like(a)

np.zeros  - Return a new array of given shape and type, filled with zeros.
np.zeros_like - Return an array of zeros with the same shape and type as a given array.

np.r_ - 




